---
sidebar_position: 2
sidebar_label: Quickstart User Ready
tags:
    - guide
    - quickstart
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quickstart User Ready
On this page you will integrate your web application with Nblocks hosted login, add protection to your app and have your users authenticate to get access. We call this beeing user ready and you will accomplish this in no time. 
In each step you will apply a few lines of code to make redirects using the familiar OpenId Connect / OAuth 2.0 flows, obtain user tokens, protect your app and make use of our prebuilt fully flexible user portal.

## Nblocks login

The integration essentially consists of two parts where the first part is where you redirect the user's browser to Nblocks and the second one is where the user is redirected back to your app with profile information.

This can be implemented for multiple use cases such as if you have:
- A frontend only
- A backend only
- A frontend and a backend in which case we recommend that you implement it in your backend.

After you're done with this part your application will have a login flow with sign in, sign up, and SSO.

The Nblocks team provides, maintains, and adds code examples for popular languages continuously. 
However, if you have a specific need not covered by this quickstart yet, you'll find documentation on how to use Nblocks with any language in our API reference [API reference](https://nebulr-group.github.io/nblocks-api-docs).


:::info Prerequisites

1. If you haven't already, [sign up](/docs/getting-started/signup) for Nblocks and get access to your [app id](/docs/getting-started/id-and-keys) 
1. An existing web application that can run on http://localhost:8080.

:::

<details><summary>Not using http://localhost:8080?</summary>

Nblocks is using sensible defaults to make development and integrations simpler. 
To use another application address you need to change your app profile configuration.

**Using the Nblocks Admin portal**

The easiest way to do so is configuring your callback URLs in the [authentication settings](./authentication-settings#security)

**Using the terminal tool**

**Step 1. Open `app-configuration.json`.**   
This json file was downloaded when you signed up for Nblocks through terminal.

**Step 2. Change the Oauth 2.0 callback uris.**   
In the json file, change the defaultCallbackUri and redirectUris to the correct address for your application.
```json
"defaultCallbackUri": "http://localhost:3000/auth/oauth-callback",
"redirectUris": [
	"http://localhost:3000/auth/oauth-callback"
],
```

**Step 3. Save the changes by pushing the updated configuration back to Nblocks**
```console
npx @nebulr-group/nblocks-cli push-app
```

</details>


### Step 1: Redirect users to Nblocks login

#### Add a redirect action
Open your project source code in an editor of your choice. 
Then add an action in your app that will redirect the user to the Nblocks "Login" endpoint at `https://auth-stage.nblocks.cloud/url/login/APP_ID` where `APP_ID` is your known app id.

A good practice is to add a new app route `/login` that triggers this action, so that when you navigate to `http://localhost:8080/login` the redirect is performed.


##### Example code
<Tabs>
<TabItem value="reactjs" label="ReactJS" default>

Create a new component that we call `LoginComponent`. Routes can be created with [react-router](https://reactrouter.com/) plugin
```tsx
import { useEffect } from "react";

export default function LoginComponent() {

  // highlight-start
  const APP_ID = "XXX";
  // highlight-end

  useEffect(() => {
    // Immediately redirect the web browser to Nblocks login
    window.location.replace(`https://auth-stage.nblocks.cloud/url/login/${APP_ID}`);
  })

  return ("");
}
```

</TabItem>

<TabItem value="nextjs" label="NextJS" default>

Create a new file `/app/auth/login/page.jsx`

```tsx title=/app/auth/login/page.jsx
import { redirect } from 'next/navigation'
 
export default function Login() {

  // highlight-start
  const APP_ID = "XXX";
  // highlight-end

  // Immediately redirect the web browser to Nblocks login
  redirect(`https://auth-stage.nblocks.cloud/url/login/${APP_ID}`);
}
```
</TabItem>

<TabItem value="angular" label="Angular" default>

Create a new component that we call `LoginComponent`.
```ts
@Component({
  template: '',
})
export class LoginComponent {
  constructor(
  ) {
    // highlight-start
    const APP_ID = "XXX";
    // highlight-end

    window.location.replace(`https://auth-stage.nblocks.cloud/url/login/${APP_ID}`);
  }
}
```

</TabItem>

<TabItem value="pseudo" label="Can't find your stack?" default>

If you cannot find your stack in the example code you need to integrate this part manually.

Essentially you should redirect the user to the url described in the [API reference](https://nebulr-group.github.io/nblocks-api-docs/#short-hand-authorize) for the `/url/login` endpoint. 
You can use the other language tabs to get an idea how this can be done.

Don't forget to make a request, by joining our [Discord](https://discord.gg/kjWYdZ6f6G) and spell it out, and we'll be happy to add this stack as an example.
</TabItem>

</Tabs>

:::tip

Curious in what more ways you can use the  `/url/login` endpoint? See the [API reference](https://nebulr-group.github.io/nblocks-api-docs/#short-hand-authorize)

:::

### Step 2: Receive the user back to your app
When the user completes authentication with Nblocks Login, the user is redirected back to your app with a code token that we will resolve into something more useful.
The URL containing the code token will look like this: `http://localhost:8080/auth/oauth-callback?code=XXXXXX....`

#### Add a callback route and use the code to exchange for user tokens
Add a new route `/auth/oauth-callback` in your app that will act as a handler when the user is returned. In this handler you should retrieve the code token from the URL mentioned above and save it.

Then we will exchange this code token it for more useful user profile information. 
Your app should make an API call to the Nblocks "Token" endpoint at `https://auth-stage.nblocks.cloud/token/code/APP_ID` where `APP_ID` is your known app id in order to make this exchange.
The returning response contains secure token data and a resolved user profile which you can print to the console or display on your frontend page.

##### Example code
<Tabs>
<TabItem value="reactjs" label="ReactJS" default>

Create a new component that we call `CallbackComponent`.

```jsx
import { useEffect, useState } from "react";
import { useLocation } from 'react-router-dom';
import { jwtVerify, createRemoteJWKSet } from "jose";

// Users will get back to this component after finishing login
export default function CallbackComponent() {

  const location = useLocation();
  const urlSearch = new URLSearchParams(location.search);
  const code = urlSearch.get("code");

  const APP_ID = "XXX";

  const [accessToken, setAccessToken] = useState();

  useEffect(() => {
    if (code) {
      handleCallback(code);
    }
  }, [code]);

  const handleCallback = async (code) => {
    // Make the API call to Nblocks
    const result = await fetch(`https://auth-stage.nblocks.cloud/token/code/${APP_ID}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          code: code,
        }),
      }
    ).then(res => res.json());

    // Verify the result using public keys from Nblocks JWKS
    const { access_token, refresh_token, id_token } = tokens;
    const { payload } = await jwtVerify(
      access_token, createRemoteJWKSet(
          new URL('https://auth-stage.nblocks.cloud/.well-known/jwks.json')
      ), { issuer: 'https://auth-stage.nblocks.cloud' }
    );

    // Store the result in component state and localstorage
    setAccessToken(payload);
    window.localStorage.setItem('access_token', access_token);
    window.localStorage.setItem('refresh_token', refresh_token);
    window.localStorage.setItem('id_token', id_token);
  };

  if (accessToken)
    return (<p>Logged in</p>);
  else
    return (<p>Not logged in</p>);
}
```

</TabItem>

<TabItem value="nextjs" label="NextJS" default>

Create a new page that we call `Callback`.

```tsx title=/app/auth/oauth-callback/page.jsx
'use client'

import { useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";

// Users will get back to this component after finishing login
export default function Callback() {

  const searchParams = useSearchParams();

  const APP_ID = "XXX";

  const [tokens, setTokens] = useState();

  useEffect(() => {
    const code = searchParams.get('code');
    if (code) {
      handleCallback(code);
    }
  }, [searchParams]);

  const handleCallback = async (code) => {
    // Make the API call to Nblocks
    const result = await fetch(`https://auth-stage.nblocks.cloud/token/code/${APP_ID}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          code: code,
        }),
      }
    ).then(res => res.json());

    // Store the result in component state and localstorage
    setTokens(result);

    window.localStorage.setItem('access_token', result.access_token);
  };

  if (tokens)
    return (<p>Hello {tokens.user_profile.name}</p>);
  else
    return (<p>Not logged in</p>);
}
```
</TabItem>

<TabItem value="angular" label="Angular" default>

Create a new component that we call `CallbackComponent`.

```ts
@Component({
  template: '<div><p *ngIf="!tokens">Not logged in</p><p *ngIf="tokens">Hello {{tokens.user_profile.name}}</p></div>',
})

export class CallbackComponent {

  private APP_ID = "XXX";

  private tokens: any;

  constructor(
    private route: ActivatedRouteSnapshot,
    private http: HttpClient,
  ) {
    this.handleCallback(this.route.queryParams['code'])
  }

  private handleCallback(code: string) {
    // Make the API call to Nblocks
    this.http.post(`https://auth-stage.nblocks.cloud/token/code/${this.APP_ID}`, {
      code: code
    }).subscribe((response) => {
      // Store the result in component state and localstorage
      this.tokens = response;
      window.localStorage.setItem('access_token', result.access_token);
    });
  }
}

```

</TabItem>

<TabItem value="pseudo" label="Can't find your stack?" default>

If you cannot find your stack in the example code you need to integrate this part manually.

Essentially you should make a call to the `/token/code` endpoint described in the [API reference](https://nebulr-group.github.io/nblocks-api-docs/#shorthand-get-tokens).

Don't forget to make a request, by joining our [Discord](https://discord.gg/kjWYdZ6f6G) and spell it out, and we'll be happy to add this stack as an example.
</TabItem>

</Tabs>

**Token Response example**   
This is shows the structure of the token response.
```json
{
  "token_type": "Bearer",
  "expires_in": 3600,
  "access_token": "eyJhbGciOiJQ...",
  "refresh_token": "eyJhbGciOiJQ...",
  "id_token": "eyJhbGciOiJQ...",
  "user_profile": {
    "name": "John Doe",
    "family_name": "Doe",
    "given_name": "John",
    ...
  }
}
```

:::tip

Curious in what more ways you can use the  `/token/code` endpoint? See the [API reference](https://nebulr-group.github.io/nblocks-api-docs/#shorthand-get-tokens)

:::

### Step 3: Test it

#### 1. Start your app
Start your application so that it is accessible on [http://localhost:8080](http://localhost:8080)

#### 2. Navigate to /login and get redirected to Nblocks Login
Navigate to [http://localhost:8080/login](http://localhost:8080/login). Your code redirects the user to Nblocks Login.
![Nblocks Login](../assets/nblocks-login/login-screen.png)

#### 3. Sign up for a new account
Since you don't have a previous user account click "**Sign up**".

![Nblocks Sign up](../assets/nblocks-login/signup-screen.png)

You can sign up with your email or use Google or Microsoft SSO for a faster process. These SSO's are available as Demo integrations from Nblocks from start.

![Nblocks Google SSO](../assets/nblocks-login/google-screen.png)

Here we have clicked to sign up with Google. The Google login screen is shown.

#### 4. Return to your app as a logged in user
After logging in, you get redirected back to your application again and we see the name of the logged in user.
![Callback](../assets/nblocks-login/callback-screen.png)

:::tip Didn't the callback work?

Make sure your application is running on port 8080. That is the most common misstake.
If not, check the prerequisites section again to learn how to use another port than 8080.

:::

**That's all!** You've completed integrating with Nblock Login. Next step is to add protection to your app so that only logged in users can access its content.

## Protect your app

Securing your app when you have logged in users is crucial. Here's some examples that points out why this is important.
* You only want logged in users to access the app, otherwise they should be prompted with a login.
* You have frontend views, components or backend endpoints that only some users should be able to access. E.g. an analytics view for only users with the privilege `ANALYTICS_READ`.

Below we'll show how easily you can add protection to your app by using the tokens obtained from the logged in user.

### Short info about the access token
When you completed the Nblocks login part of this quickstart you got hold of a couple of tokens that was signed securely by Nblocks.
One of them, the access token holds the users access information and this information can be used to protect your app.
The token is encoded in a format called [JWT](https://jwt.io) for greater portability and security. If we decode the access token it looks like this:

```json

{
    "aid": "63d2ab029e23db0afb07a5a7",
    "tid": "63d2b5c18892e10022e08399",
    // highlight-start
    "scope": "AUTHENTICATED USER_READ USER_WRITE TENANT_READ TENANT_WRITE",
    "role": "OWNER",
    // highlight-end
    "plan": "FREE",
    "iat": 1685648418,
    "exp": 1685652018,
    "aud": [
        "63d2ab029e23db0afb07a5a7",
        "https://app-stage.nblocks.cloud"
    ],
    "iss": "https://auth-stage.nblocks.cloud",
    "sub": "63d2b5c18892e10022e083a2"
}

```

:::tip Decoding and verifying JWTs

JWTs is a well known concept in security. That means there are plenty of libraries for many software stacks to decode and verify them into readable JSON. Here's a extensive [list](https://jwt.io/libraries) of different libraries.
We'll be using one of these in our code examples.
:::

In the structure above, we highlighted the parts that we'll be focusing on in this part of the guide.
* The `role` property indicates the role of the user.
* The `scope` property specifies the privileges the user obtains when logging in with that role. This can be used for more fine-grained protection and role-based access control on individual features.
* You can [configure the roles and privileges](./roles-and-privileges) to your specific needs.


### Protect your frontend

:::tip Don't have a frontend?

You can skip this part if you don't have a frontend.

:::

In this part we'll be showing you how easy it is to secure your application frontend with Nblocks. 
You'll **Protect a route**, that only some users can access and others will be redirected back.

After you're done with this part your application frontend will be able to show/hide content depending on what user login.

#### Protect a route

Protecting a whole route is as simple as protecting part of the web page. 
But instead of hiding/showing content we can redirect the user to another page if the requirements are not met.

<Tabs>
<TabItem value="reactjs" label="ReactJS" default>

Imaging you have a React router structure like this.

```jsx
<BrowserRouter>
    <Routes>
        <Route path="/auth/login" element={<LoginComponent />} />
        <Route path="/auth/oauth-callback" element={<CallbackComponent />} />
        <Route path="/home" element={<HomeComponent />} />
        <Route path="/analytics" element={<AnalyticsComponent />} />
    </Routes>
</BrowserRouter>

```
We want to protect all routes for only logged in users, otherwise they should be redirected back to Login again. Therefore we need to use the access token to protect this route conditionally. 
This can easily be done likt this: 

Create a new component that we call `ProtectedRoute`.
```tsx
import { useEffect, useState } from "react";
import { decodeJwt } from "jose";
import { Navigate } from 'react-router-dom';

export default function ProtectedRoute({roles, privileges, redirectTo, children}) {

  // This will be our variable telling if the user is granted access or if we should redirect to login
  // Initially this variable is true since we don't want to redirect before resolving the 
  const [granted, setGranted] = useState(true);
  
  // This is the path which users without access should be redirect to
  const redirectPath = redirectTo ? redirectTo : "/auth/login";

  useEffect(() => {
    // Retrieve the access token JWT from localstorage
    const accessToken = window.localStorage.getItem('access_token');
    if (accessToken) {
      const decoded = decodeJwt(accessToken);
      setGranted(hasRoleOrPrivilege(decoded));
    } else {
      setGranted(false);
    }
  }, []);

  // Helper method to see if the users token contains any of the required roles or privileges 
  const hasRoleOrPrivilege = (decoded) => {
    return roles ? roles.includes(decoded.role) : false || privileges ? privileges.some(scope => decoded.scope.includes(scope)) : false;
  }

  // Only if granted should we render the component children
  if (granted)
    return (children);
  else
    return (<Navigate to={redirectPath} replace />);
}

```

Now you can use this component in your app routing like this:

```jsx
<BrowserRouter>
    <Routes>
        <Route path="/auth/login" element={<LoginComponent />} />
        <Route path="/auth/oauth-callback" element={<CallbackComponent />} />
        // highlight-start
        <Route path="*" element={
            <ProtectedRoute privileges={["AUTHENTICATED"]}>
              <Routes>
              // highlight-end
                <Route path="/home" element={<HomeComponent />} />
                <Route path="/analytics" element={<AnalyticsComponent />} />
                // highlight-start
              </Routes>
            </ProtectedRoute>
          }
        />
        // highlight-end
    </Routes>
</BrowserRouter>

```

If you now try to navigate to either `/home` or `/analytics` without being logged in, you will be redirected to login.


<details><summary>More examples</summary>

Our ProtectedRoute can do more like redirecting to a forbidden page if the user is logged in but are missing a required privilege.  Here's how that would look:

```jsx
<BrowserRouter>
    <Routes>
        <Route path="/auth/login" element={<LoginComponent />} />
        <Route path="/auth/oauth-callback" element={<CallbackComponent />} />
        <Route path="/forbidden" element={<ForbiddenComponent />} />
        <Route path="*" element={
            <ProtectedRoute privileges={["AUTHENTICATED"]}>
              <Routes>
                <Route path="/home" element={<HomeComponent />} />
                <Route path="/analytics" element={
                    <ProtectedRoute
                      privileges={["ANALYTICS"]}
                      redirectTo="/forbidden"
                    >
                      <AnalyticsComponent />
                    </ProtectedRoute>
                  }
                />
              </Routes>
            </ProtectedRoute>
          }
        />
    </Routes>
</BrowserRouter>
```

</details>

</TabItem>

<TabItem value="nextjs" label="NextJS" default>

Imaging you have a NextJS page component that renders analytics data looking like this.

```tsx title="/app/analytics/page.jsx"
'use client'

const AnalyticsPage = () => {
    return (
      <div>
        <h1>Analytics</h1>
        <DetailsGraph />
        <RevenueTable />
      </div>
    )
}

export default AnalyticsPage;
```

We want to protect this page for only logged in users, otherwise they should be redirected back to Login again. 
Therefore we need to use the access token to protect this route conditionally. 
This can easily be done likt this:

Create a new component `/components/protected-route.jsx`

```tsx title="/components/protected-route.jsx"
"use client";

import React, { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { decodeJwt } from "jose";

function ProtectedRoute<T>(
  Component: React.ComponentType<T>,
  args: { roles, privileges, redirectTo }
) {
  return (props: T) => {
    // This is the path which users without access should be redirect to
    const redirectTo = args.redirectTo || "/auth/login";
    const { roles, privileges } = args;
    const router = useRouter();

    const [granted, setGranted] = useState(false);

    useEffect(() => {
      // Retrieve the access token JWT from localstorage
      const accessToken = window.localStorage.getItem("access_token");
      if (accessToken) {
        const decoded = decodeJwt(accessToken);
        if (hasRoleOrPrivilege(decoded)) {
          setGranted(true);
        } else {
          router.push(redirectTo);
        }
      } else {
        router.push(redirectTo);
      }
    }, []);

    // Helper method to see if the users token contains any of the required roles or privileges 
    const hasRoleOrPrivilege = (decoded: any) => {
      return roles ? roles.includes(decoded.role) : false || privileges ? privileges.some((scope) => decoded.scope.includes(scope)) : false;
    };

    // Only if granted should we render component
    if (granted)
      return (
        <>
          <Component {...props!} />
        </>
      );
  };
}

export default ProtectedRoute;
```

Now you can use this ProtectedRoute component to secure the AnalyticsPage like this:

```tsx title="/app/analytics/page.jsx"
'use client'

// highlight-start
import IsAuth from "@/components/protected-route";
// highlight-end

const AnalyticsPage = () => {
    return (
      <div>
        <h1>Analytics</h1>
        <DetailsGraph />
        <RevenueTable />
      </div>
    )
}
// highlight-start
export default ProtectedRoute(AnalyticsPage, {privileges: ["AUTHENTICATED"]);
// highlight-end
```

If you now try to navigate to `/analytics` without being logged in, you will be redirected to login.

<details><summary>More examples</summary>

Our ProtectedRoute can do more like redirecting to a forbidden page if the user is logged in but are missing a required privilege. Here's how that would look:

```jsx

export default ProtectedRoute(AnalyticsPage, {privileges: ["ANALYTICS"], redirectTo="/forbidden");

export default ProtectedRoute(AnalyticsPage, {roles: ["ADMIN"]);
```

</details>

</TabItem>

<TabItem value="pseudo" label="Can't find your stack?" default>

If you cannot find your stack in the example code you need to integrate this part manually.

You can use the other language tabs to get an idea how this can be done.

Don't forget to make a request, by joining our [Discord](https://discord.gg/kjWYdZ6f6G) and spell it out, and we'll be happy to add this stack as an example.

</TabItem>

</Tabs>

### Protect your backend

:::tip Don't have a backend?

You can skip this part if you don't have a backend.

:::

Securing your backend is even more important than securing your frontend since the backend usually holds sensitive and important information that we never want to return to a user that is either not logged in or not the rightful recipient of that information.

In this part we'll be showing you how easy it is to secure your application backend with Nblocks. You will **protect an endpoint with role based access control**, so that only users with the right privilege can query it.

After you're done with this part you will have an application backend that is secure and ready for production.

#### How will the user provide the token to the backend on each request?

* If your developing an application with both a backend and a frontend it is best practise to let the frontend attach the access token as an `authorization` header on each request to the backend.
* When developing a backend only application you could either still resort to clients providing the `authorization` header in each request or store the accessToken in a session cookie once you obtained it in the Nblocks Login part of this quickstart. Clients will provide this cookie automatically on every future request.

#### Protect an endpoint with role based access control

<Tabs>
<TabItem value="expressjs" label="ExpressJS" default>

Imagine you have declared two endpoints, `/dashboardData` and `/analyticsData` in your express app like this.
```ts
const app = express();

app.get('/dashboardData', (req, res) => {
  ...
});

app.get('/analyticsData', (req, res) => {
  ...
});

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

We want both of the endpoints to require the user to be logged in before rendering a result. 
The `/analyticsData` endpoint should only be accessable for users with the privilege `ANALYTICS_READ`.
All this can easily be done with Express middlewares:

Create a new file in which we declare two middlewares.
```ts
import { jwtVerify, createRemoteJWKSet } from 'jose';

// Verifies and decodes the access token from the authorization header
const jwtMiddleware = async (req, res, next) => {
  if (req.headers['authorization']) {
    try {
      // Get the public key to verify the token signed by Nblocks
      const JWKS = createRemoteJWKSet(
        new URL('https://auth-stage.nblocks.cloud/.well-known/jwks.json')
      );

      // Deconstruct user from the verified token and store the decoded information in a variable that can be used by other middlewares
      const { payload: user } = await jwtVerify(
        req.headers['authorization'], JWKS, { issuer: 'https://auth-stage.nblocks.cloud' }
      );
      req.user = user;
      next();
    } catch (e) {
      next(e);
    }
  }
};

// Grants or denies access based on the decoded token from jwtMiddleware
const protectedRoute = ({ roles, privileges }) => {
  return (req, res, next) => {
    if (req.user) {
      if (
        roles
          ? roles.includes(req.user.role)
          : false || privileges
          ? privileges.some((scope) => req.user.scope.includes(scope))
          : false
      ) {
        next();
      } else {
        res.status(403).send({ message: 'Forbidden' });
      }
    } else {
      res.status(401).send({ message: 'Unauthorized' });
    }
  };
};

export { jwtMiddleware, protectedRoute }
```

:::tip Handling users not logged in

If you're building a backend only app, you might want to redirect users to `/auth/login` instead of rendering a `401 Unauthorized` error in case they're unauthorized for a better user experience.
:::

Heading back to the initial express app file we can now make use of these middleware to start protecting the endpoints!

```ts
// highlight-start
import { jwtMiddleware, protectedRoute } from './middlewares'
// highlight-end

const app = express();

// highlight-start
// First middleware that decodes tokens
app.use(jwtMiddleware);

// Restrict all endpoints globally with protectedRoute to require authenticated users
app.use(protectedRoute({privileges: ['AUTHENTICATED']}));
// highlight-end

app.get('/dashboardData', (req, res) => {
  ...
});

// highlight-start
// Restrict /analyticsData with protectedRoute to require users with ANALYTICS_READ privilege
app.get('/analyticsData', protectedRoute({privileges: ['ANALYTICS_READ']}), (req, res) => {
// highlight-end
  ...
});

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

<details><summary>More examples</summary>

Our `protectedRoute` middleware can be activated in other ways, like this:

```ts
// Protect all endpoints
app.use(protectedRoute({privileges: ['AUTHENTICATED']}));

// Protect /analyticsData
app.use("/analyticsData", protectedRoute({privileges: ['AUTHENTICATED']}));

// Protect using wildcards
app.use("/secret/*", protectedRoute({roles: ['ADMIN']}));

```

</details>

</TabItem>

<TabItem value="pseudo" label="Can't find your stack?" default>

If you cannot find your stack in the example code you need to integrate this part manually.

You can use the other language tabs to get an idea how this can be done.

Don't forget to make a request, by joining our [Discord](https://discord.gg/kjWYdZ6f6G) and spell it out, and we'll be happy to add this stack as an example.

</TabItem>

</Tabs>

**That's all!** With this part we've show the best practises how you can protect your backend application using the tokens generated from Nblocks Login. Next up is how we can let the logged in users invite others.

## User list
In the last last part of the quickstart we're adding a user management view to let the users manage and invite others to their tenant.

You can embedd this view straight into your app either by using Iframes or redirecting the user to it. It looks like this:

![User list](../assets/user-management/user-list.png)

### Implement it

:::tip

The url can either be rendered as an Iframe or you can redirect the user to it.

:::

There will be two Nblocks endpoints involved when requesting to render the user list.
1. First we need to get the [handover code](https://nebulr-group.github.io/nblocks-api-docs/#handover-code) which is unique to the user. This is done using `/handover/code` endpoint.
1. Then we will use the code to render the [user list view](https://nebulr-group.github.io/nblocks-api-docs/#user-management-portal-users) using the `/user-management-portal/users` endpoint.

#### Example code
<Tabs>
<TabItem value="reactjs" label="ReactJS" default>

Create a new component that we call `UserList`.

```tsx
import { useEffect, useState } from "react";

export default function UserList() {
  const [url, setUrl] = useState();

  const APP_ID = "XXX";

  useEffect(() => {
    createUrl();
  }, []);

    const createUrl = async () => {
    // Retrieve the access token JWT from localstorage
    const accessToken = window.localStorage.getItem("access_token");

    // Get the handover code from Nblocks
    const result = await fetch(
      `https://auth-stage.nblocks.cloud/handover/code/${APP_ID}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          accessToken,
        }),
      }
    ).then((res) => res.json());

    // Create the user management portal url
    setUrl(
      `https://backendless-stage.nblocks.cloud/user-management-portal/users?code=${result.code}`
    );
  };

  // Render the url as an iframe
  return <iframe width="100%" height="500px" src={url}></iframe>;
}

```

Now you can render the `UserList` component anywhere you want to have the user access it.

</TabItem>

<TabItem value="nextjs" label="NextJS" default>

Create a new file at `app/users/page.jsx`

```tsx
'use client'

import { useState, useEffect } from "react";

export default function UserList() {
  const APP_ID = "XXX";

const [url, setUrl] = useState();

  useEffect(() => {
    createUrl();
  }, []);

    const createUrl = async () => {
    // Retrieve the access token JWT from localstorage
    const accessToken = window.localStorage.getItem("access_token");

    // Get the handover code from Nblocks
    const result = await fetch(
      `https://auth-stage.nblocks.cloud/handover/code/${APP_ID}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          accessToken,
        }),
      }
    ).then((res) => res.json());

    // Create the user management portal url
    setUrl(
      `https://backendless-stage.nblocks.cloud/user-management-portal/users?code=${result.code}`
    );
  };

  // Render the url as an iframe
  return <iframe width="100%" height="500px" src={url}></iframe>;
}

```

Now you can navigate to `/users` and see the user list render.


</TabItem>

<TabItem value="pseudo" label="Can't find your stack?" default>

If you cannot find your stack in the example code you need to integrate this part manually.

You can use the other language tabs to get an idea how this can be done.

Don't forget to make a request, by joining our [Discord](https://discord.gg/kjWYdZ6f6G) and spell it out, and we'll be happy to add this stack as an example.

</TabItem>

</Tabs>

:::tip How to get the access token?

In the User Login Quickstart, we stored the access token into Localstorage as a fast and easy way later retrieve it again. Other ways could be to save in-memory in a global state or React context.
:::

**Now your done!**   
That was the last step of the quickstart and we've covered the three things that has made your app user ready.

## Next steps

- Add SSO alternatives to your login experience, replacing the Demo integrations.


If you haven't already, join our [Discord](https://discord.gg/kjWYdZ6f6G)